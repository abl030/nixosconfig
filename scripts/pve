#!/usr/bin/env bash
# Enhanced Proxmox CLI Wrapper
# Wraps proxmox-ops with ergonomic commands and jq-formatted output

set -euo pipefail

# Color output helpers
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

error() {
    echo -e "${RED}Error: $*${NC}" >&2
    exit 1
}

success() {
    echo -e "${GREEN}$*${NC}"
}

info() {
    echo -e "${BLUE}$*${NC}"
}

warning() {
    echo -e "${YELLOW}$*${NC}"
}

# proxmox-ops is in PATH via writeShellApplication
PROXMOX_OPS="proxmox-ops"

# Proxmox host configuration
PROXMOX_HOST="192.168.1.12"
PROXMOX_NODE="prom"

# Repo root for nix run commands
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

# Load Proxmox API token from file if not already set
load_pve_token() {
    if [[ -n "${PROXMOX_VE_API_TOKEN:-}" ]]; then
        return 0
    fi

    local token_file="${PVE_TOKEN_FILE:-$HOME/.pve_token}"
    if [[ ! -f "$token_file" && -f /tmp/pve_token ]]; then
        warning "Token file not found at $token_file; using /tmp/pve_token for this run."
        token_file="/tmp/pve_token"
    fi

    if [[ ! -f "$token_file" ]]; then
        error "PVE token file not found. Set PVE_TOKEN_FILE or create $HOME/.pve_token."
    fi

    local token_line
    token_line="$(head -n1 "$token_file")"
    if [[ -z "$token_line" || "$token_line" != *"="* ]]; then
        error "Invalid token format in $token_file. Expected: user@realm!tokenid=secret"
    fi

    export PROXMOX_VE_API_TOKEN="$token_line"
}

require_repo_root() {
    if [[ ! -f "$REPO_ROOT/hosts.nix" ]] || [[ ! -f "$REPO_ROOT/secrets/.sops.yaml" ]]; then
        error "Run this from the nixosconfig repo root (missing hosts.nix or secrets/.sops.yaml)."
    fi
}

resolve_host_config_dir() {
    local name="$1"
    local config_path

    if ! command -v nix >/dev/null 2>&1; then
        return 1
    fi

    if ! config_path=$(nix eval --raw --impure --expr "let hosts = import $REPO_ROOT/hosts.nix; in toString hosts.${name}.configurationFile" 2>/dev/null); then
        return 1
    fi

    if [[ -z "$config_path" ]]; then
        return 1
    fi

    dirname "$config_path"
}

remove_hosts_entry() {
    local name="$1"
    local hosts_file="$REPO_ROOT/hosts.nix"
    local temp_file
    temp_file="$(mktemp)"

    awk -v name="$name" '
        $0 ~ "^  "name" = \\{" {skip=1; next}
        skip && /^  \};/ {skip=0; next}
        !skip {print}
    ' "$hosts_file" > "$temp_file"

    mv "$temp_file" "$hosts_file"
}

remove_sops_age_key() {
    local name="$1"
    local sops_file="$REPO_ROOT/secrets/.sops.yaml"
    local temp_file
    temp_file="$(mktemp)"

    awk -v name="$name" '
        $0 ~ ("&"name) {next}
        $0 ~ ("# *"name"([[:space:]]|$)") {next}
        {print}
    ' "$sops_file" > "$temp_file"

    mv "$temp_file" "$sops_file"
}

update_sops_keys() {
    local secrets_dir="$REPO_ROOT/secrets"
    local sops_config="$secrets_dir/.sops.yaml"

    if ! resolve_sops_identity; then
        error "No valid SOPS age key found."
    fi

    command -v sops >/dev/null 2>&1 || error "sops is required to update keys."

    if [[ ! -f "$sops_config" ]]; then
        error "Missing $sops_config"
    fi

    while IFS= read -r secret_file; do
        sops --config "$sops_config" updatekeys --yes "$secret_file" >/dev/null
    done < <(find "$secrets_dir/secrets" -type f)
}

resolve_sops_identity() {
    if [[ -n "${SOPS_AGE_KEY:-}" ]]; then
        return 0
    fi

    local keyfile
    for keyfile in "/root/.config/sops/age/keys.txt" "/var/lib/sops-nix/key.txt"; do
        if [[ -f "$keyfile" ]]; then
            export SOPS_AGE_KEY_FILE="$keyfile"
            return 0
        fi
    done

    if command -v ssh-to-age >/dev/null 2>&1; then
        if age_key=$(sudo ssh-to-age -private-key -i /etc/ssh/ssh_host_ed25519_key 2>/dev/null); then
            export SOPS_AGE_KEY="$age_key"
            return 0
        fi

        local sshkey="${HOME}/.ssh/id_ed25519"
        if [[ -f "$sshkey" ]] && age_key=$(ssh-to-age -private-key -i "$sshkey" 2>/dev/null); then
            export SOPS_AGE_KEY="$age_key"
            return 0
        fi
    fi

    return 1
}

# Helper: Query pvesh for VM current status (real-time stats)
# Returns JSON with cpu, mem, diskread, diskwrite, netin, netout, uptime
get_vm_stats() {
    local vmid=$1
    # shellcheck disable=SC2029
    ssh "root@$PROXMOX_HOST" "pvesh get /nodes/$PROXMOX_NODE/qemu/$vmid/status/current --output-format json 2>/dev/null"
}

# Helper: Format bytes to human readable
bytes_to_human() {
    local bytes=$1
    if (( bytes < 1024 )); then
        echo "${bytes}B"
    elif (( bytes < 1048576 )); then
        echo "$(( bytes / 1024 ))KB"
    elif (( bytes < 1073741824 )); then
        printf "%.1fMB" "$(echo "scale=1; $bytes / 1048576" | bc)"
    else
        printf "%.1fGB" "$(echo "scale=1; $bytes / 1073741824" | bc)"
    fi
}

# Helper: Format seconds to human readable uptime
seconds_to_uptime() {
    local seconds=$1
    local days=$(( seconds / 86400 ))
    local hours=$(( (seconds % 86400) / 3600 ))
    local mins=$(( (seconds % 3600) / 60 ))

    if (( days > 0 )); then
        echo "${days}d ${hours}h"
    elif (( hours > 0 )); then
        echo "${hours}h ${mins}m"
    else
        echo "${mins}m"
    fi
}

# Helper: Calculate rate between two samples
# Args: value1 value2 interval_seconds
calculate_rate() {
    local val1=$1
    local val2=$2
    local interval=$3
    echo "scale=2; ($val2 - $val1) / $interval" | bc
}

# Usage information
usage() {
    cat <<EOF
pve - Enhanced Proxmox CLI Wrapper

USAGE:
    pve <command> [arguments]

VIEWING/LISTING:
    list, ls              List all VMs (table format)
    ps [--live] [--throughput]
                          Show only running VMs
                          --live: Show real-time CPU% and memory usage
                          --throughput: Show disk/network I/O rates
    status <vmid>         Get status of specific VM
    stats <vmid>          Show detailed real-time statistics for VM
    info <vmid>           Show detailed VM configuration
    config <vmid>         Show raw Proxmox config
    top                   Live monitor (refreshes every 2s, press q to quit)

NETWORK:
    ip <vmid>             Get IP address of VM
    ips                   List all running VMs with IPs

LIFECYCLE:
    start <vmid>          Start VM
    stop <vmid>           Stop VM (immediate)
    shutdown <vmid>       Shutdown VM (graceful)
    restart <vmid>        Restart VM
    destroy <vmid>        Destroy VM (requires confirmation)

PROVISIONING:
    new                   Interactive VM creation wizard
    remove <name>         Remove VM config/secrets and destroy via OpenTofu
    integrate <name> <ip> <vmid>
                          Post-provision fleet integration
    plan [tofu args]      OpenTofu plan (loads token from ~/.pve_token)
    apply [tofu args]     OpenTofu apply (loads token from ~/.pve_token)
    next-vmid [start] [end]
                          Get next available VMID
    defs                  Show VM definitions

RESOURCE MANAGEMENT:
    resize-cpu <vmid> <cores>
                          Change CPU cores
    resize-ram <vmid> <mb>
                          Change RAM (in MB)
    resize-disk <vmid> <disk> <size>
                          Resize disk (e.g., scsi0 +10G)
    add-disk <vmid> <size> [storage] [disk]
                          Add new disk to VM

HOST/STORAGE:
    storage               Show storage status
    host                  Show Proxmox host info

UTILITY:
    wait <vmid>           Wait for VM to be SSH accessible
    console <vmid>        Stream serial console (interactive)
    help                  Show this help
    version               Show version

EXAMPLES:
    pve list              # List all VMs
    pve ps | jq           # Show running VMs as JSON
    pve ip 110            # Get IP of VMID 110
    pve start 110         # Start VMID 110
    pve console 9003      # Stream serial console
    pve new               # Create config + OpenTofu plan/apply
    pve remove test2      # Remove config/secrets and destroy VM via OpenTofu
    pve plan              # tofu plan with Proxmox token
    pve apply             # tofu apply with Proxmox token
EOF
}

# Parse command
CMD="${1:-help}"
shift || true

case "$CMD" in
    # Viewing/Listing
    list|ls)
        info "Listing all VMs..."
        "$PROXMOX_OPS" list | jq -r '
            ["VMID", "NAME", "STATUS", "CPU", "RAM(GB)", "DISK"],
            ["----", "----", "------", "---", "-------", "----"],
            (.[] | select(.type=="qemu") | [
                .vmid,
                .name,
                .status,
                .maxcpu // "?",
                ((.maxmem // 0) / 1024 / 1024 / 1024 | floor),
                (.maxdisk // 0 | if . > 0 then (. / 1024 / 1024 / 1024 | floor | tostring + "G") else "?" end)
            ]) | @tsv
        ' | column -t
        ;;

    ps)
        # Check for flags
        show_live=false
        show_throughput=false
        for arg in "$@"; do
            case "$arg" in
                --live) show_live=true ;;
                --throughput) show_throughput=true ;;
            esac
        done

        if [[ "$show_live" == "true" ]] || [[ "$show_throughput" == "true" ]]; then
            info "Showing running VMs with real-time stats..."

            # Get running VMIDs
            running_vms=$("$PROXMOX_OPS" list | jq -r '.[] | select(.type=="qemu" and .status=="running") | .vmid')

            if [[ "$show_throughput" == "true" ]]; then
                # Sample twice with 1 second interval for throughput calculation
                declare -A sample1_disk_r sample1_disk_w sample1_net_rx sample1_net_tx
                declare -A sample2_disk_r sample2_disk_w sample2_net_rx sample2_net_tx

                # First sample
                for vmid in $running_vms; do
                    stats=$(get_vm_stats "$vmid")
                    sample1_disk_r[$vmid]=$(echo "$stats" | jq -r '.diskread // 0')
                    sample1_disk_w[$vmid]=$(echo "$stats" | jq -r '.diskwrite // 0')
                    sample1_net_rx[$vmid]=$(echo "$stats" | jq -r '.netin // 0')
                    sample1_net_tx[$vmid]=$(echo "$stats" | jq -r '.netout // 0')
                done

                sleep 1

                # Second sample
                for vmid in $running_vms; do
                    stats=$(get_vm_stats "$vmid")
                    sample2_disk_r[$vmid]=$(echo "$stats" | jq -r '.diskread // 0')
                    sample2_disk_w[$vmid]=$(echo "$stats" | jq -r '.diskwrite // 0')
                    sample2_net_rx[$vmid]=$(echo "$stats" | jq -r '.netin // 0')
                    sample2_net_tx[$vmid]=$(echo "$stats" | jq -r '.netout // 0')
                done

                # Print header
                echo "VMID	NAME	CPU%	MEM	DISK R/W	NET RX/TX"
                echo "----	----	----	---	--------	---------"

                # Calculate and display rates
                for vmid in $running_vms; do
                    stats=$(get_vm_stats "$vmid")
                    name=$(echo "$stats" | jq -r '.name // "?"')
                    cpu=$(echo "$stats" | jq -r '.cpu // 0 | . * 100')
                    mem_used=$(echo "$stats" | jq -r '.mem // 0')
                    mem_max=$(echo "$stats" | jq -r '.maxmem // 0')

                    # Calculate rates (bytes per second)
                    disk_r_rate=$(calculate_rate "${sample1_disk_r[$vmid]}" "${sample2_disk_r[$vmid]}" 1)
                    disk_w_rate=$(calculate_rate "${sample1_disk_w[$vmid]}" "${sample2_disk_w[$vmid]}" 1)
                    net_rx_rate=$(calculate_rate "${sample1_net_rx[$vmid]}" "${sample2_net_rx[$vmid]}" 1)
                    net_tx_rate=$(calculate_rate "${sample1_net_tx[$vmid]}" "${sample2_net_tx[$vmid]}" 1)

                    mem_gb=$(echo "scale=1; $mem_used / 1073741824" | bc)
                    mem_max_gb=$(echo "scale=1; $mem_max / 1073741824" | bc)

                    disk_r_human=$(bytes_to_human "${disk_r_rate%.*}")
                    disk_w_human=$(bytes_to_human "${disk_w_rate%.*}")
                    net_rx_human=$(bytes_to_human "${net_rx_rate%.*}")
                    net_tx_human=$(bytes_to_human "${net_tx_rate%.*}")

                    printf "%s\t%s\t%.1f%%\t%.1f/%.1fG\t%s/%s\t%s/%s\n" \
                        "$vmid" "$name" "$cpu" "$mem_gb" "$mem_max_gb" \
                        "$disk_r_human" "$disk_w_human" \
                        "$net_rx_human" "$net_tx_human"
                done | column -t -s $'\t'
            else
                # Just live stats (no throughput)
                echo "VMID	NAME	STATUS	CPU%	MEM	UPTIME"
                echo "----	----	------	----	---	------"

                for vmid in $running_vms; do
                    stats=$(get_vm_stats "$vmid")
                    name=$(echo "$stats" | jq -r '.name // "?"')
                    status=$(echo "$stats" | jq -r '.status // "?"')
                    cpu=$(echo "$stats" | jq -r '.cpu // 0 | . * 100')
                    mem_used=$(echo "$stats" | jq -r '.mem // 0')
                    mem_max=$(echo "$stats" | jq -r '.maxmem // 0')
                    uptime=$(echo "$stats" | jq -r '.uptime // 0')

                    mem_gb=$(echo "scale=1; $mem_used / 1073741824" | bc)
                    mem_max_gb=$(echo "scale=1; $mem_max / 1073741824" | bc)
                    mem_pct=$(echo "scale=0; ($mem_used * 100) / $mem_max" | bc)
                    uptime_human=$(seconds_to_uptime "$uptime")

                    printf "%s\t%s\t%s\t%.1f%%\t%.1fG/%.1fG (%s%%)\t%s\n" \
                        "$vmid" "$name" "$status" "$cpu" "$mem_gb" "$mem_max_gb" "$mem_pct" "$uptime_human"
                done | column -t -s $'\t'
            fi
        else
            # Original ps output (no stats)
            info "Showing running VMs..."
            "$PROXMOX_OPS" list | jq -r '
                ["VMID", "NAME", "STATUS", "CPU", "RAM(GB)"],
                ["----", "----", "------", "---", "-------"],
                (.[] | select(.type=="qemu" and .status=="running") | [
                    .vmid,
                    .name,
                    .status,
                    .maxcpu // "?",
                    ((.maxmem // 0) / 1024 / 1024 / 1024 | floor)
                ]) | @tsv
            ' | column -t
        fi
        ;;

    status)
        [[ -z "${1:-}" ]] && error "Usage: pve status <vmid>"
        "$PROXMOX_OPS" status "$1"
        ;;

    stats)
        [[ -z "${1:-}" ]] && error "Usage: pve stats <vmid>"
        vmid=$1

        info "VM $vmid - Real-time Statistics"
        echo "===================================="

        # Get two samples 1 second apart for rate calculation
        stats1=$(get_vm_stats "$vmid")
        sleep 1
        stats2=$(get_vm_stats "$vmid")

        # Extract values
        name=$(echo "$stats2" | jq -r '.name // "unknown"')
        status=$(echo "$stats2" | jq -r '.status // "unknown"')
        uptime=$(echo "$stats2" | jq -r '.uptime // 0')
        cpu=$(echo "$stats2" | jq -r '.cpu // 0 | . * 100')
        cpus=$(echo "$stats2" | jq -r '.cpus // "?"')
        mem_used=$(echo "$stats2" | jq -r '.mem // 0')
        mem_max=$(echo "$stats2" | jq -r '.maxmem // 0')

        # Guest agent memory info
        mem_free=$(echo "$stats2" | jq -r '.ballooninfo.free_mem // 0')
        mem_total=$(echo "$stats2" | jq -r '.ballooninfo.total_mem // 0')

        # Disk I/O
        disk_read1=$(echo "$stats1" | jq -r '.diskread // 0')
        disk_write1=$(echo "$stats1" | jq -r '.diskwrite // 0')
        disk_read2=$(echo "$stats2" | jq -r '.diskread // 0')
        disk_write2=$(echo "$stats2" | jq -r '.diskwrite // 0')

        # Network I/O
        net_in1=$(echo "$stats1" | jq -r '.netin // 0')
        net_out1=$(echo "$stats1" | jq -r '.netout // 0')
        net_in2=$(echo "$stats2" | jq -r '.netin // 0')
        net_out2=$(echo "$stats2" | jq -r '.netout // 0')

        # Calculate rates
        disk_read_rate=$(calculate_rate "$disk_read1" "$disk_read2" 1)
        disk_write_rate=$(calculate_rate "$disk_write1" "$disk_write2" 1)
        net_in_rate=$(calculate_rate "$net_in1" "$net_in2" 1)
        net_out_rate=$(calculate_rate "$net_out1" "$net_out2" 1)

        # Format output
        uptime_human=$(seconds_to_uptime "$uptime")
        mem_gb=$(echo "scale=1; $mem_used / 1073741824" | bc)
        mem_max_gb=$(echo "scale=1; $mem_max / 1073741824" | bc)
        mem_pct=$(echo "scale=0; ($mem_used * 100) / $mem_max" | bc)

        disk_read_total=$(bytes_to_human "$disk_read2")
        disk_write_total=$(bytes_to_human "$disk_write2")
        disk_read_rate_h=$(bytes_to_human "${disk_read_rate%.*}")
        disk_write_rate_h=$(bytes_to_human "${disk_write_rate%.*}")

        net_in_total=$(bytes_to_human "$net_in2")
        net_out_total=$(bytes_to_human "$net_out2")
        net_in_rate_h=$(bytes_to_human "${net_in_rate%.*}")
        net_out_rate_h=$(bytes_to_human "${net_out_rate%.*}")

        # Display
        echo "Name:      $name"
        echo "Status:    $status (uptime: $uptime_human)"
        echo ""
        echo "CPU:       ${cpu}% ($cpus cores available)"
        echo ""
        echo "Memory:    ${mem_gb}G / ${mem_max_gb}G (${mem_pct}% used)"
        if [[ "$mem_total" != "0" ]]; then
            mem_free_gb=$(echo "scale=1; $mem_free / 1073741824" | bc)
            mem_total_gb=$(echo "scale=1; $mem_total / 1073741824" | bc)
            echo "  Guest:   ${mem_total_gb}G total, ${mem_free_gb}G free"
        fi
        echo ""
        echo "Disk I/O:"
        echo "  Read:    $disk_read_total total (${disk_read_rate_h}/s current)"
        echo "  Write:   $disk_write_total total (${disk_write_rate_h}/s current)"
        echo ""
        echo "Network:"
        echo "  RX:      $net_in_total total (${net_in_rate_h}/s current)"
        echo "  TX:      $net_out_total total (${net_out_rate_h}/s current)"
        ;;

    top)
        info "Proxmox VMs - Live Monitor (press Ctrl+C to quit)"
        echo ""

        # Trap Ctrl+C to exit cleanly
        trap 'echo ""; success "Exiting..."; exit 0' INT

        while true; do
            # Gather all data FIRST before clearing screen
            output=""

            # Build header
            output+="${BLUE}Proxmox VMs - Live Monitor${NC}\n"
            output+="Updated: $(date '+%Y-%m-%d %H:%M:%S')\n"
            output+="\n"

            # Get running VMIDs
            running_vms=$("$PROXMOX_OPS" list | jq -r '.[] | select(.type=="qemu" and .status=="running") | .vmid')

            if [[ -z "$running_vms" ]]; then
                output+="No running VMs\n"
            else
                # Sample twice with 1 second interval
                declare -A sample1_disk_r sample1_disk_w sample1_net_rx sample1_net_tx
                declare -A sample2_disk_r sample2_disk_w sample2_net_rx sample2_net_tx

                # First sample
                for vmid in $running_vms; do
                    stats=$(get_vm_stats "$vmid")
                    sample1_disk_r[$vmid]=$(echo "$stats" | jq -r '.diskread // 0')
                    sample1_disk_w[$vmid]=$(echo "$stats" | jq -r '.diskwrite // 0')
                    sample1_net_rx[$vmid]=$(echo "$stats" | jq -r '.netin // 0')
                    sample1_net_tx[$vmid]=$(echo "$stats" | jq -r '.netout // 0')
                done

                sleep 1

                # Second sample and build table
                table_output=""
                for vmid in $running_vms; do
                    stats=$(get_vm_stats "$vmid")
                    sample2_disk_r[$vmid]=$(echo "$stats" | jq -r '.diskread // 0')
                    sample2_disk_w[$vmid]=$(echo "$stats" | jq -r '.diskwrite // 0')
                    sample2_net_rx[$vmid]=$(echo "$stats" | jq -r '.netin // 0')
                    sample2_net_tx[$vmid]=$(echo "$stats" | jq -r '.netout // 0')

                    name=$(echo "$stats" | jq -r '.name // "?"')
                    cpu=$(echo "$stats" | jq -r '.cpu // 0 | . * 100')
                    mem_used=$(echo "$stats" | jq -r '.mem // 0')
                    mem_max=$(echo "$stats" | jq -r '.maxmem // 0')
                    mem_pct=$(echo "scale=0; ($mem_used * 100) / $mem_max" | bc)

                    # Calculate rates
                    disk_r_rate=$(calculate_rate "${sample1_disk_r[$vmid]}" "${sample2_disk_r[$vmid]}" 1)
                    disk_w_rate=$(calculate_rate "${sample1_disk_w[$vmid]}" "${sample2_disk_w[$vmid]}" 1)
                    net_rx_rate=$(calculate_rate "${sample1_net_rx[$vmid]}" "${sample2_net_rx[$vmid]}" 1)
                    net_tx_rate=$(calculate_rate "${sample1_net_tx[$vmid]}" "${sample2_net_tx[$vmid]}" 1)

                    disk_r_human=$(bytes_to_human "${disk_r_rate%.*}")
                    disk_w_human=$(bytes_to_human "${disk_w_rate%.*}")
                    net_rx_human=$(bytes_to_human "${net_rx_rate%.*}")
                    net_tx_human=$(bytes_to_human "${net_tx_rate%.*}")

                    table_output+=$(printf "%s\t%s\t%.1f%%\t%s%%\t%s/%s\t%s/%s\n" \
                        "$vmid" "$name" "$cpu" "$mem_pct" \
                        "$disk_r_human" "$disk_w_human" \
                        "$net_rx_human" "$net_tx_human")
                    table_output+="\n"
                done

                # Format table
                formatted_table=$(echo -e "VMID\tNAME\tCPU%\tMEM%\tDISK R/W\tNET RX/TX\n----\t----\t----\t----\t--------\t---------\n$table_output" | column -t -s $'\t')
                output+="$formatted_table\n"
            fi

            output+="\n"
            output+="${BLUE}Refreshing in 2 seconds... (Ctrl+C to quit)${NC}\n"

            # NOW clear screen and display everything at once
            clear
            echo -e "$output"

            sleep 1
        done
        ;;

    info)
        [[ -z "${1:-}" ]] && error "Usage: pve info <vmid>"
        info "VM Configuration for VMID $1:"
        "$PROXMOX_OPS" config "$1" | grep -E "^(cores|memory|net0|scsi0|ide2|sockets|cpu)" || true
        ;;

    config)
        [[ -z "${1:-}" ]] && error "Usage: pve config <vmid>"
        "$PROXMOX_OPS" config "$1"
        ;;

    # Network
    ip)
        [[ -z "${1:-}" ]] && error "Usage: pve ip <vmid>"
        "$PROXMOX_OPS" get-ip "$1"
        ;;

    ips)
        info "VM IP Addresses (running VMs only)..."
        "$PROXMOX_OPS" list | jq -r '.[] | select(.type=="qemu" and .status=="running") | .vmid' | while read -r vmid; do
            ip=$("$PROXMOX_OPS" get-ip "$vmid" 2>/dev/null || echo "unknown")
            name=$("$PROXMOX_OPS" config "$vmid" 2>/dev/null | grep "^name:" | cut -d' ' -f2 || echo "unknown")
            echo "$vmid	$name	$ip"
        done | column -t -N "VMID,NAME,IP"
        ;;

    # Lifecycle
    start)
        [[ -z "${1:-}" ]] && error "Usage: pve start <vmid>"
        info "Starting VM $1..."
        "$PROXMOX_OPS" start "$1"
        success "VM $1 started"
        ;;

    stop)
        [[ -z "${1:-}" ]] && error "Usage: pve stop <vmid>"
        warning "Stopping VM $1 (immediate)..."
        "$PROXMOX_OPS" stop "$1"
        success "VM $1 stopped"
        ;;

    shutdown)
        [[ -z "${1:-}" ]] && error "Usage: pve shutdown <vmid>"
        info "Shutting down VM $1 (graceful)..."
        "$PROXMOX_OPS" shutdown "$1"
        success "VM $1 shutdown initiated"
        ;;

    restart)
        [[ -z "${1:-}" ]] && error "Usage: pve restart <vmid>"
        info "Restarting VM $1..."
        "$PROXMOX_OPS" stop "$1"
        sleep 3
        "$PROXMOX_OPS" start "$1"
        success "VM $1 restarted"
        ;;

    destroy)
        [[ -z "${1:-}" ]] && error "Usage: pve destroy <vmid>"
        warning "WARNING: This will permanently destroy VM $1!"
        echo -n "Type 'yes' to confirm: "
        read -r confirm
        if [[ "$confirm" == "yes" ]]; then
            "$PROXMOX_OPS" destroy "$1" yes
            success "VM $1 destroyed"
        else
            info "Destroy cancelled"
            exit 1
        fi
        ;;

    # Provisioning
    new)
        info "Launching interactive VM wizard..."
        nix run .#new-vm
        ;;

    remove)
        [[ -z "${1:-}" ]] && error "Usage: pve remove <name>"
        require_repo_root
        load_pve_token

        name="$1"

        if ! command -v nix >/dev/null 2>&1; then
            error "nix is required to remove VM config entries."
        fi

        if [[ "$(nix eval --json --impure --expr "let hosts = import $REPO_ROOT/hosts.nix; in builtins.hasAttr \"${name}\" hosts")" != "true" ]]; then
            error "Host '$name' not found in hosts.nix"
        fi

        vmid="$(nix eval --raw --impure --expr "let hosts = import $REPO_ROOT/hosts.nix; in if hosts ? ${name} && hosts.${name} ? proxmox && hosts.${name}.proxmox ? vmid then toString hosts.${name}.proxmox.vmid else \"\"" 2>/dev/null || true)"
        config_dir="$(resolve_host_config_dir "$name" || true)"

        warning "This will remove host config, sops keys, and destroy VM '$name'${vmid:+ (VMID $vmid)}."
        if [[ -n "$config_dir" ]]; then
            warning "Host config dir: $config_dir"
        fi
        echo -n "Type '${name}' to confirm: "
        read -r confirm
        if [[ "$confirm" != "$name" ]]; then
            info "Remove cancelled"
            exit 1
        fi

        if [[ -n "$config_dir" && -d "$config_dir" ]]; then
            rm -rf "$config_dir"
        fi

        remove_hosts_entry "$name"
        remove_sops_age_key "$name"
        update_sops_keys

        tofu_workdir="${TOFU_WORKDIR:-$REPO_ROOT/vms/tofu/.state}"
        info "Planning OpenTofu changes..."
        if ! TOFU_WORKDIR="$tofu_workdir" nix run .#tofu-plan; then
            error "OpenTofu plan failed."
        fi

        echo -n "Apply OpenTofu changes now? [y/N]: "
        read -r apply_confirm
        case "$apply_confirm" in
            y|Y|yes|YES) ;;
            *) info "Apply skipped."; exit 0 ;;
        esac

        info "Applying OpenTofu changes..."
        TOFU_WORKDIR="$tofu_workdir" nix run .#tofu-apply
        success "Remove flow complete."
        ;;

    integrate)
        [[ -z "${3:-}" ]] && error "Usage: pve integrate <name> <ip> <vmid>"
        info "Integrating VM $1 into fleet..."
        nix run .#post-provision-vm "$1" "$2" "$3"
        ;;

    plan)
        load_pve_token
        (cd "$REPO_ROOT" && nix run .#tofu-plan -- "$@")
        ;;

    apply)
        load_pve_token
        (cd "$REPO_ROOT" && nix run .#tofu-apply -- "$@")
        ;;

    next-vmid)
        "$PROXMOX_OPS" next-vmid "${1:-100}" "${2:-199}"
        ;;

    defs)
        info "VM Definitions:"
        nix eval .#vms --json 2>/dev/null | jq -r '
            "=== Managed VMs ===",
            (.managed | to_entries[] | "  \(.key): VMID \(.value.vmid) - \(.value.purpose // "no description")"),
            "",
            "=== Imported VMs (readonly) ===",
            (.imported | to_entries[] | "  \(.key): VMID \(.value.vmid) - \(.value.purpose // "no description")")
        '
        ;;

    # Resource Management
    resize-cpu)
        [[ -z "${2:-}" ]] && error "Usage: pve resize-cpu <vmid> <cores>"
        info "Resizing VM $1 to $2 cores..."
        "$PROXMOX_OPS" configure "$1" "$2" "" || error "Failed to resize CPU"
        success "VM $1 CPU resized to $2 cores"
        ;;

    resize-ram)
        [[ -z "${2:-}" ]] && error "Usage: pve resize-ram <vmid> <mb>"
        info "Resizing VM $1 to $2 MB RAM..."
        "$PROXMOX_OPS" configure "$1" "" "$2" || error "Failed to resize RAM"
        success "VM $1 RAM resized to $2 MB"
        ;;

    resize-disk)
        [[ -z "${3:-}" ]] && error "Usage: pve resize-disk <vmid> <disk> <size>"
        info "Resizing disk $2 on VM $1 to $3..."
        "$PROXMOX_OPS" resize "$1" "$2" "$3" || error "Failed to resize disk"
        success "Disk $2 on VM $1 resized to $3"
        ;;

    add-disk)
        [[ -z "${2:-}" ]] && error "Usage: pve add-disk <vmid> <size> [storage] [disk]"
        info "Adding disk to VM $1..."
        "$PROXMOX_OPS" create-disk "$1" "$2" "${3:-}" "${4:-}" || error "Failed to add disk"
        success "Disk added to VM $1"
        ;;

    # Host/Storage
    storage)
        info "Proxmox Storage Status:"
        "$PROXMOX_OPS" storage
        ;;

    host)
        info "Proxmox Host Information:"
        # Get basic host info via SSH
        ssh root@192.168.1.12 'echo "Hostname: $(hostname)"; echo "Uptime: $(uptime -p)"; echo "Load: $(cat /proc/loadavg | cut -d" " -f1-3)"'
        ;;

    # Utility
    wait)
        [[ -z "${1:-}" ]] && error "Usage: pve wait <vmid>"
        ip=$("$PROXMOX_OPS" get-ip "$1" 2>/dev/null || error "Could not get IP for VM $1")
        info "Waiting for VM $1 ($ip) to be SSH accessible..."
        "$PROXMOX_OPS" wait-ssh "$ip" 300 abl030
        success "VM $1 is now accessible"
        ;;

    console)
        [[ -z "${1:-}" ]] && error "Usage: pve console <vmid>"
        "$PROXMOX_OPS" console "$1"
        ;;

    version)
        echo "pve CLI wrapper v1.0.0"
        "$PROXMOX_OPS" --version 2>/dev/null || echo "proxmox-ops.sh (bundled)"
        ;;

    help|-h|--help)
        usage
        ;;

    *)
        error "Unknown command: $CMD\n\nRun 'pve help' for usage"
        ;;
esac
